===== PROJECT TREE =====
/mnt/c/Users/91739/Documents/CD_project/Chitradhara/apps/web/src
â”œâ”€â”€ hooks
â”‚Â Â  â””â”€â”€ useAuth.tsx
â””â”€â”€ lib
    â”œâ”€â”€ api.ts
    â”œâ”€â”€ auth.ts
    â”œâ”€â”€ firebase.ts
    â”œâ”€â”€ supabase.ts
    â”œâ”€â”€ supabaseClient.ts
    â”œâ”€â”€ supabaseServer.ts
    â”œâ”€â”€ utils.ts
    â””â”€â”€ validate.ts
/mnt/c/Users/91739/Documents/CD_project/Chitradhara/apps/web/app
â”œâ”€â”€ about
â”‚Â Â  â””â”€â”€ page.tsx
â”œâ”€â”€ api
â”‚Â Â  â”œâ”€â”€ cleanup-video
â”‚Â Â  â”‚Â Â  â””â”€â”€ route.ts
â”‚Â Â  â”œâ”€â”€ seed-video
â”‚Â Â  â”‚Â Â  â””â”€â”€ route.ts
â”‚Â Â  â”œâ”€â”€ test-ensure-user
â”‚Â Â  â”‚Â Â  â””â”€â”€ route.ts
â”‚Â Â  â”œâ”€â”€ upload
â”‚Â Â  â”‚Â Â  â””â”€â”€ route.ts
â”‚Â Â  â””â”€â”€ videos
â”‚Â Â      â”œâ”€â”€ [id]
â”‚Â Â      â”‚Â Â  â”œâ”€â”€ restore
â”‚Â Â      â”‚Â Â  â”‚Â Â  â””â”€â”€ route.ts
â”‚Â Â      â”‚Â Â  â”œâ”€â”€ route.ts
â”‚Â Â      â”‚Â Â  â””â”€â”€ signed-url
â”‚Â Â      â”‚Â Â      â””â”€â”€ route.ts
â”‚Â Â      â”œâ”€â”€ route.ts
â”‚Â Â      â””â”€â”€ trash
â”‚Â Â          â””â”€â”€ route.ts
â”œâ”€â”€ favicon.ico
â”œâ”€â”€ feed
â”‚Â Â  â””â”€â”€ page.tsx
â”œâ”€â”€ forbidden.tsx
â”œâ”€â”€ globals.css
â”œâ”€â”€ layout.tsx
â”œâ”€â”€ login
â”‚Â Â  â””â”€â”€ page.tsx
â”œâ”€â”€ not-found.tsx
â”œâ”€â”€ page.tsx
â”œâ”€â”€ profile
â”‚Â Â  â”œâ”€â”€ ProfileHeader.tsx
â”‚Â Â  â””â”€â”€ page.tsx
â”œâ”€â”€ signup
â”‚Â Â  â””â”€â”€ page.tsx
â”œâ”€â”€ upload
â”‚Â Â  â””â”€â”€ page.tsx
â””â”€â”€ videos
    â”œâ”€â”€ [id]
    â”‚Â Â  â”œâ”€â”€ WatchClient.tsx
    â”‚Â Â  â””â”€â”€ page.tsx
    â””â”€â”€ trash
        â””â”€â”€ page.tsx
/mnt/c/Users/91739/Documents/CD_project/Chitradhara/apps/web/components
â”œâ”€â”€ AuthProvider.tsx
â”œâ”€â”€ ClientAuthProvider.tsx
â”œâ”€â”€ Hello.tsx
â”œâ”€â”€ Navbar.tsx
â”œâ”€â”€ PageLayout.tsx
â”œâ”€â”€ RequireAuth.tsx
â””â”€â”€ VideoCard.tsx
/mnt/c/Users/91739/Documents/CD_project/Chitradhara/apps/web/tests
â”œâ”€â”€ day12.spec.ts
â”œâ”€â”€ day13.spec.ts
â”œâ”€â”€ day14.spec.ts
â”œâ”€â”€ day15.spec.ts
â”œâ”€â”€ seo-check.js
â””â”€â”€ setup
    â””â”€â”€ auth.setup.ts

1 directory, 6 files



===== FILE DATA FROM TREE HIERARCHY =====
===== src/hooks/useAuth.tsx =====
// apps/web/src/hooks/useAuth.tsx
"use client";

import { useEffect, useState } from "react";
import { onAuthStateChanged, User } from "firebase/auth";
import { auth } from "@/lib/firebase";

export function useAuth() {
  const [user, setUser] = useState<User | null>(auth.currentUser);
  const [loading, setLoading] = useState<boolean>(true);

  useEffect(() => {
    const unsub = onAuthStateChanged(auth, (u) => {
      setUser(u);
      setLoading(false);
    });
    return () => unsub();
  }, []);

  return { user, loading };
}



===== src/lib/api.ts =====
import { onAuthStateChanged } from "firebase/auth";
import { auth } from "@/lib/firebase";

/** Wait for Firebase user token */
async function getToken(): Promise<string> {
  if (auth.currentUser) return auth.currentUser.getIdToken();

  return await new Promise<string>((resolve, reject) => {
    const timeout = setTimeout(() => {
      unsub();
      reject(new Error("Not authenticated"));
    }, 5000);

    const unsub = onAuthStateChanged(
      auth,
      async (u) => {
        clearTimeout(timeout);
        unsub();
        if (!u) return reject(new Error("Not authenticated"));

        try {
          const t = await u.getIdToken();
          resolve(t);
        } catch (err) {
          reject(err);
        }
      },
      (err) => {
        clearTimeout(timeout);
        unsub();
        reject(err);
      }
    );
  });
}

/** Generic API fetch wrapper */
export async function apiFetch<T = any>(
  url: string,
  options: RequestInit = {}
): Promise<T> {
  const token = await getToken();

  const res = await fetch(url, {
    ...options,
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${token}`,
      ...(options.headers || {}),
    },
    cache: "no-store",
  });

  const text = await res.text();
  let body: any = null;
  try {
    body = text ? JSON.parse(text) : null;
  } catch {
    body = text;
  }

  if (!res.ok) {
    const msg =
      (body && body.error) ||
      (body && body.message) ||
      body ||
      res.statusText;
    throw new Error(msg || "API error");
  }

  return body as T;
}

/* ----- Convenience wrappers ----- */
export function getMyVideos(url: string = "/api/videos") {
  return apiFetch(url);
}

export function getTrashedVideos() {
  return apiFetch("/api/videos/trash");
}

export function updateVideo(id: string, data: any) {
  return apiFetch(`/api/videos/${id}`, {
    method: "PATCH",
    body: JSON.stringify(data),
  });
}

export function softDeleteVideo(id: string) {
  return apiFetch(`/api/videos/${id}`, {
    method: "PATCH",
    body: JSON.stringify({ action: "trash" }),
  });
}

export function restoreVideo(id: string) {
  return apiFetch(`/api/videos/${id}`, {
    method: "PATCH",
    body: JSON.stringify({ action: "restore" }),
  });
}

export function deleteVideo(id: string) {
  return apiFetch(`/api/videos/${id}`, {
    method: "PATCH",
    body: JSON.stringify({ action: "delete" }),
  });
}

export const moveToTrash = softDeleteVideo;
export const permanentDeleteVideo = deleteVideo;

export function getFreshSignedUrl(id: string) {
  return apiFetch(`/api/videos/${id}/signed-url`);
}



===== src/lib/auth.ts =====
import { getAuth } from "firebase-admin/auth";
import { initializeApp, cert, getApps } from "firebase-admin/app";

if (!getApps().length) {
  initializeApp({
    credential: cert({
      projectId: process.env.FIREBASE_PROJECT_ID!,
      clientEmail: process.env.FIREBASE_CLIENT_EMAIL!,
      privateKey: process.env.FIREBASE_PRIVATE_KEY!.replace(/\\n/g, "\n"),
    }),
  });
}

// âœ… shared helper for all routes
export async function getUserId(req: Request) {
  const token = req.headers.get("authorization")?.replace("Bearer ", "");
  if (!token) throw new Error("Missing token");
  const decoded = await getAuth().verifyIdToken(token);
  return decoded.uid;
}

export const authOptions = {};



===== src/lib/firebase.ts =====
// apps/web/src/lib/firebase.ts
import { initializeApp, getApps, getApp } from "firebase/app";
import { getAuth } from "firebase/auth";
import { getStorage } from "firebase/storage";

const firebaseConfig = {
  apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY!,
  authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN!,
  projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID!,
  storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET!,
  messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID!,
  appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID!,
};

// initialize or reuse app (safe for Hot reload)
export const app = getApps().length ? getApp() : initializeApp(firebaseConfig);

// client-side Firebase services used by app components
export const auth = getAuth(app);
export const firebaseStorage = getStorage(app);



===== src/lib/supabase.ts =====
// apps/web/src/lib/supabase.ts
export { supabaseClient as supabase } from "./supabaseClient";



===== src/lib/supabaseClient.ts =====
// apps/web/src/lib/supabaseClient.ts
import { createClient } from "@supabase/supabase-js";

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;

// Client-side Supabase (browser safe)
export const supabaseClient = createClient(supabaseUrl, supabaseAnonKey);



===== src/lib/supabaseServer.ts =====
// apps/web/src/lib/supabaseServer.ts
import { createClient } from "@supabase/supabase-js";

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY!;

// Server-side client (use service role key for admin actions)
export const supabaseServer = createClient(supabaseUrl, supabaseServiceKey, {
  auth: {
    persistSession: false,
  },
});



===== src/lib/utils.ts =====
// apps/web/src/lib/utils.ts

/**
 * Validate if a string is a proper UUID (v1â€“v5).
 */
export function isValidUUID(id: string): boolean {
  return /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(id);
}

// You can keep other utility exports here too
export function formatDate(dateString: string) {
  const date = new Date(dateString);
  return date.toLocaleDateString("en-IN", {
    year: "numeric",
    month: "short",
    day: "numeric",
  });
}

export function classNames(...classes: (string | boolean | null | undefined)[]) {
  return classes.filter(Boolean).join(" ");
}



===== src/lib/validate.ts =====
// apps/web/src/lib/validate.ts

// Simple UUID v4 validator
export function isValidUUID(id: string): boolean {
  const uuidRegex =
    /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
  return uuidRegex.test(id);
}



===== app/about/page.tsx =====
export default function AboutPage() {
  return <h1>About Chitradhara ğŸ¥</h1>;
}



===== app/api/cleanup-video/route.ts =====
import { NextResponse } from "next/server";
import { supabaseServer } from "@/lib/supabaseServer";
import { getUserId } from "@/lib/auth";

export async function POST(req: Request) {
  try {
    const uid = await getUserId(req);
    const { error } = await supabaseServer.from("videos").delete().eq("creator_id", uid);
    if (error) throw error;
    return NextResponse.json({ success: true });
  } catch (e: any) {
    return NextResponse.json({ error: e.message }, { status: 500 });
  }
}



===== app/api/seed-video/route.ts =====
import { NextResponse } from "next/server";
import { supabaseServer } from "@/lib/supabaseServer";
import { getUserId } from "@/lib/auth";

export async function POST(req: Request) {
  try {
    const uid = await getUserId(req);
    const filePath = `${uid}/seed-${Date.now()}.mp4`;

    const { error } = await supabaseServer.from("videos").insert({
      title: "Seeded Test Video",
      file_path: filePath,
      creator_id: uid,
      creator_email: "test@seed.local",
      is_deleted: false,
      deleted_at: null,
      is_private: true,
    });

    if (error) throw error;
    return NextResponse.json({ success: true });
  } catch (e: any) {
    return NextResponse.json({ error: e.message }, { status: 500 });
  }
}



===== app/api/test-ensure-user/route.ts =====
import { NextResponse } from "next/server";
import { getApps, initializeApp, cert } from "firebase-admin/app";
import { getAuth } from "firebase-admin/auth";

export const dynamic = "force-dynamic";

if (!getApps().length) {
  initializeApp({
    credential: cert({
      projectId: process.env.FIREBASE_PROJECT_ID!,
      clientEmail: process.env.FIREBASE_CLIENT_EMAIL!,
      privateKey: process.env.FIREBASE_PRIVATE_KEY!.replace(/\\n/g, "\n"),
    }),
  });
}

export async function POST(req: Request) {
  try {
    if (process.env.NODE_ENV === "production") {
      return NextResponse.json({ error: "Not allowed in production" }, { status: 403 });
    }

    const { email, password } = await req.json().catch(() => ({} as any));
    if (!email || !password) {
      return NextResponse.json({ error: "Email and password required" }, { status: 400 });
    }

    const auth = getAuth();
    let user;
    try {
      user = await auth.getUserByEmail(email);
      await auth.updateUser(user.uid, { password });
    } catch {
      user = await auth.createUser({ email, password, emailVerified: true, disabled: false });
    }

    return NextResponse.json({ ok: true, uid: user.uid });
  } catch (e: any) {
    console.error("ensure-user error:", e);
    return NextResponse.json({ error: e.message || "Failed" }, { status: 500 });
  }
}



===== app/api/upload/route.ts =====
// apps/web/app/api/upload/route.ts
import { NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";
import { v4 as uuid } from "uuid";

export const dynamic = "force-dynamic";

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!,
  { auth: { persistSession: false, autoRefreshToken: false } }
);

export async function POST(req: Request) {
  try {
    const formData = await req.formData();
    const file = formData.get("file") as File;
    const title = formData.get("title") as string;
    const userId = formData.get("userId") as string;
    const userEmail = formData.get("userEmail") as string;

    if (!file || !userId) {
      return NextResponse.json({ error: "Missing file or user" }, { status: 400 });
    }

    // generate storage key
    const key = `uploads/${userId}/${uuid()}-${file.name}`;

    // upload to Supabase Storage
    const { error: uploadError } = await supabase
      .storage
      .from("videos")
      .upload(key, file, { contentType: file.type });

    if (uploadError) throw uploadError;

    // insert DB row
    const { error: insertError } = await supabase.from("videos").insert({
      title: title || file.name,
      file_path: key,
      creator_id: userId,
      creator_email: userEmail,
      deleted_at: null, // âœ… only this
    });

    if (insertError) throw insertError;

    return NextResponse.json({ success: true });
  } catch (err: any) {
    console.error("UPLOAD error:", err);
    return NextResponse.json({ error: err.message || "Upload failed" }, { status: 500 });
  }
}



===== app/api/videos/route.ts =====
import { NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";
import { getAuth } from "firebase-admin/auth";
import { initializeApp, cert, getApps } from "firebase-admin/app";

export const dynamic = "force-dynamic";

if (!getApps().length) {
  initializeApp({
    credential: cert({
      projectId: process.env.FIREBASE_PROJECT_ID!,
      clientEmail: process.env.FIREBASE_CLIENT_EMAIL!,
      privateKey: process.env.FIREBASE_PRIVATE_KEY!.replace(/\\n/g, "\n"),
    }),
  });
}

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!,
  { auth: { persistSession: false } }
);

async function getUserId(req: Request) {
  const token = req.headers.get("authorization")?.replace("Bearer ", "");
  if (!token) throw new Error("Missing token");
  const decoded = await getAuth().verifyIdToken(token);
  return decoded.uid;
}

export async function GET(req: Request) {
  try {
    const uid = await getUserId(req);

    const url = new URL(req.url);
    const page = Math.max(1, Number(url.searchParams.get("page") ?? "1"));
    const limit = Math.min(50, Math.max(5, Number(url.searchParams.get("limit") ?? "12")));
    const sort = url.searchParams.get("sort") ?? "created_at";
    const order = (url.searchParams.get("order") ?? "desc").toLowerCase() === "asc" ? "asc" : "desc";
    const title = url.searchParams.get("title") ?? "";

    const start = (page - 1) * limit;
    const end = start + limit - 1;

    let query = supabase
      .from("videos")
      .select(
        "id, title, description, url, file_path, creator_id, deleted_at, is_private, thumbnail_url, created_at",
        { count: "exact" }
      )
      .eq("creator_id", uid)
      .is("deleted_at", null)
      .order(sort, { ascending: order === "asc" })
      .range(start, end);

    if (title) {
      query = query.ilike("title", `%${title}%`);
    }

    const { data, error, count } = await query;
    if (error) {
      console.error("[GET /api/videos] error:", error);
      return NextResponse.json({ error: "Failed to fetch videos" }, { status: 500 });
    }

    const videos = await Promise.all(
      (data ?? []).map(async (v) => {
        let signed_url: string | null = null;
        let storageKey = v.file_path ?? v.url ?? null;
        if (storageKey?.startsWith("/")) storageKey = storageKey.slice(1);
        if (storageKey) {
          const { data: signedData } = await supabase.storage
            .from("videos")
            .createSignedUrl(storageKey, 60 * 60);
          signed_url = signedData?.signedUrl ?? null;
        }
        return { ...v, signed_url };
      })
    );

    return NextResponse.json({
      page,
      limit,
      total: count ?? videos.length,
      videos,
    });
  } catch (e: any) {
    const status = e?.message === "Missing token" ? 401 : 500;
    return NextResponse.json({ error: e?.message || "Internal server error" }, { status });
  }
}



===== app/api/videos/trash/route.ts =====
import { NextResponse } from "next/server";
import { supabaseServer } from "@/lib/supabaseServer";
import { getUserId } from "@/lib/auth";

export async function GET(req: Request) {
  try {
    const uid = await getUserId(req);

    const { data, error } = await supabaseServer
      .from("videos")
      .select("id, title, description, deleted_at, created_at")
      .eq("creator_id", uid)
      .not("deleted_at", "is", null)   // âœ… only trashed
      .order("created_at", { ascending: false });

    if (error) throw error;

    return NextResponse.json({ videos: data ?? [] });
  } catch (e: any) {
    return NextResponse.json({ error: e.message }, { status: 500 });
  }
}



===== app/api/videos/[id]/restore/route.ts =====
// apps/web/app/api/videos/[id]/restore/route.ts
import { NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";
import { getAuth } from "firebase-admin/auth";
import { initializeApp, cert, getApps } from "firebase-admin/app";

if (!getApps().length) {
  initializeApp({
    credential: cert({
      projectId: process.env.FIREBASE_PROJECT_ID!,
      clientEmail: process.env.FIREBASE_CLIENT_EMAIL!,
      privateKey: process.env.FIREBASE_PRIVATE_KEY!.replace(/\\n/g, "\n"),
    }),
  });
}

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!,
  { auth: { persistSession: false } }
);

function isValidUUID(id: string) {
  return /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(id);
}

async function getUid(req: Request) {
  const token = req.headers.get("authorization")?.replace("Bearer ", "");
  if (!token) throw new Error("Missing token");
  const decoded = await getAuth().verifyIdToken(token);
  return decoded.uid;
}

export async function POST(req: Request, context: { params: Promise<{ id: string }> }) {
  try {
    const { id } = await context.params;
    if (!isValidUUID(id)) {
      return NextResponse.json({ error: "Video not found" }, { status: 404 });
    }

    const uid = await getUid(req);

    const { data: video } = await supabase
      .from("videos")
      .select("id, creator_id")
      .eq("id", id)
      .maybeSingle();

    if (!video) return NextResponse.json({ error: "Video not found" }, { status: 404 });
    if (video.creator_id !== uid) return NextResponse.json({ error: "Forbidden" }, { status: 403 });

    const { data: updated, error: updErr } = await supabase
      .from("videos")
      .update({ deleted_at: null }) // âœ… only deleted_at
      .eq("id", id)
      .select("id, title, deleted_at")
      .maybeSingle();

    if (updErr) return NextResponse.json({ error: "Failed to restore video" }, { status: 500 });
    if (!updated) return NextResponse.json({ error: "Video not updated" }, { status: 404 });

    return NextResponse.json(updated);
  } catch (e: any) {
    const status = e?.message === "Missing token" ? 401 : 500;
    return NextResponse.json({ error: e?.message || "Internal server error" }, { status });
  }
}



===== app/api/videos/[id]/route.ts =====
// apps/web/app/api/videos/[id]/route.ts
import { NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";
import { getAuth } from "firebase-admin/auth";
import { initializeApp, cert, getApps } from "firebase-admin/app";

export const dynamic = "force-dynamic";

if (!getApps().length) {
  initializeApp({
    credential: cert({
      projectId: process.env.FIREBASE_PROJECT_ID!,
      clientEmail: process.env.FIREBASE_CLIENT_EMAIL!,
      privateKey: process.env.FIREBASE_PRIVATE_KEY!.replace(/\\n/g, "\n"),
    }),
  });
}

// server-side supabase (service role)
const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!,
  { auth: { persistSession: false } }
);

async function getUserId(req: Request) {
  const token = req.headers.get("authorization")?.replace("Bearer ", "");
  if (!token) throw new Error("Missing token");
  const decoded = await getAuth().verifyIdToken(token);
  return decoded.uid;
}

function isUUID(id: string) {
  return /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(id);
}

async function resolveParams(context: any) {
  if (!context) return null;
  const p = context.params;
  if (!p) return null;
  if (typeof (p as any).then === "function") return await p;
  return p;
}

/* ---------- GET /api/videos/[id] ---------- */
export async function GET(req: Request, context: any) {
  try {
    const p = await resolveParams(context);
    const id = p?.id;
    if (!id || !isUUID(id)) return NextResponse.json({ error: "Invalid id" }, { status: 400 });

    const { data, error } = await supabase
      .from("videos")
      .select("id, title, description, url, file_path, creator_id, deleted_at, is_private, thumbnail_url")
      .eq("id", id)
      .maybeSingle();

    if (error) return NextResponse.json({ error: "Internal" }, { status: 500 });
    if (!data || data.deleted_at) return NextResponse.json({ error: "Video not found" }, { status: 404 });

    let uid: string | null = null;
    try { uid = await getUserId(req); } catch { uid = null; }

    if (data.is_private && data.creator_id !== uid) {
      return NextResponse.json({ error: "Forbidden" }, { status: 403 });
    }

    let signed_url: string | null = null;
    const storageKey = data.file_path ?? data.url ?? null;
    if (storageKey) {
      const key = storageKey.startsWith("/") ? storageKey.slice(1) : storageKey;
      const { data: signedData } = await supabase.storage.from("videos").createSignedUrl(key, 60 * 60);
      signed_url = signedData?.signedUrl ?? null;
    }

    return NextResponse.json({ ...data, signed_url });
  } catch (e: any) {
    return NextResponse.json({ error: e?.message || "Internal server error" }, { status: 500 });
  }
}

/* ---------- PATCH /api/videos/[id] ---------- */
/* Accepts:
   { action: "trash" }   -> set deleted_at
   { action: "restore" } -> clear deleted_at
   { action: "delete" }  -> permanent delete
   { title, description } -> update fields
*/
export async function PATCH(req: Request, context: any) {
  try {
    const p = await resolveParams(context);
    const id = p?.id;
    if (!id || !isUUID(id)) return NextResponse.json({ error: "Invalid id" }, { status: 400 });

    const uid = await getUserId(req);
    let body: any = {};
    try { body = await req.json(); } catch { body = {}; }

    const { action, title, description } = body ?? {};
    const effectiveAction = action ?? "trash";

    const { data: video } = await supabase.from("videos").select("creator_id").eq("id", id).maybeSingle();
    if (!video) return NextResponse.json({ error: "Video not found" }, { status: 404 });
    if (video.creator_id !== uid) return NextResponse.json({ error: "Forbidden" }, { status: 403 });

    if (effectiveAction === "delete") {
      const { error: delErr } = await supabase.from("videos").delete().eq("id", id);
      if (delErr) return NextResponse.json({ error: "Failed to delete" }, { status: 500 });
      return NextResponse.json({ success: true });
    }

    const updateData: any = {};
    if (effectiveAction === "trash") updateData.deleted_at = new Date().toISOString();
    else if (effectiveAction === "restore") updateData.deleted_at = null;
    else {
      if (title !== undefined) updateData.title = title;
      if (description !== undefined) updateData.description = description;
    }

    const { data: updated, error: updErr } = await supabase
      .from("videos")
      .update(updateData)
      .eq("id", id)
      .select()
      .maybeSingle();

    if (updErr) return NextResponse.json({ error: "Failed to update" }, { status: 500 });
    return NextResponse.json({ success: true, updated });
  } catch (e: any) {
    const status = e?.message === "Missing token" ? 401 : 500;
    return NextResponse.json({ error: e?.message || "Internal server error" }, { status });
  }
}

/* ---------- DELETE /api/videos/[id] ---------- */
export async function DELETE(req: Request, context: any) {
  try {
    const p = await resolveParams(context);
    const id = p?.id;
    if (!id || !isUUID(id)) return NextResponse.json({ error: "Invalid id" }, { status: 400 });

    const uid = await getUserId(req);

    const { data: video } = await supabase
      .from("videos")
      .select("id, creator_id, file_path, url")
      .eq("id", id)
      .maybeSingle();

    if (!video) return NextResponse.json({ error: "Video not found" }, { status: 404 });
    if (video.creator_id !== uid) return NextResponse.json({ error: "Forbidden" }, { status: 403 });

    let storageKey: string | null = video.file_path ?? video.url ?? null;
    if (storageKey?.startsWith("/")) storageKey = storageKey.slice(1);
    if (storageKey) {
      await supabase.storage.from("videos").remove([storageKey]);
    }

    const { error: delErr } = await supabase.from("videos").delete().eq("id", id);
    if (delErr) return NextResponse.json({ error: "Failed to delete video" }, { status: 500 });

    return NextResponse.json({ success: true });
  } catch (e: any) {
    const status = e?.message === "Missing token" ? 401 : 500;
    return NextResponse.json({ error: e?.message || "Internal server error" }, { status });
  }
}



===== app/api/videos/[id]/signed-url/route.ts =====
// apps/web/app/api/videos/[id]/signed-url/route.ts
import { NextResponse } from "next/server";
import { supabaseServer } from "@/lib/supabaseServer";
import { getUserId } from "@/lib/auth";

function isUUID(id?: string) {
  return !!id && /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(id);
}

export async function GET(req: Request, context: { params: Promise<{ id: string }> }) {
  try {
    const { id } = await context.params;
    if (!isUUID(id)) return NextResponse.json({ error: "Invalid id" }, { status: 400 });

    // Require auth and ownership for ALL videos
    const uid = await getUserId(req); // throws if missing/invalid token

    const { data: video, error: fetchErr } = await supabaseServer
      .from("videos")
      .select("id, file_path, url, creator_id, deleted_at")
      .eq("id", id.trim())
      .maybeSingle();

    if (fetchErr) {
      console.error("[signed-url] supabase fetch:", fetchErr);
      return NextResponse.json({ error: "Internal" }, { status: 500 });
    }

    if (!video || video.deleted_at) {
      return NextResponse.json({ error: "Not found" }, { status: 404 });
    }

    if (video.creator_id !== uid) {
      return NextResponse.json({ error: "Forbidden" }, { status: 403 });
    }

    const storageKey = (video.file_path ?? video.url ?? "").replace(/^\//, "");
    if (!storageKey) return NextResponse.json({ error: "No storage key" }, { status: 400 });

    const { data: signedData, error: signErr } = await supabaseServer.storage
      .from("videos")
      .createSignedUrl(storageKey, 60 * 5);

    if (signErr || !signedData?.signedUrl) {
      console.error("Signed url error:", signErr);
      return NextResponse.json({ error: "Failed to generate signed url" }, { status: 500 });
    }

    return NextResponse.json({ signed_url: signedData.signedUrl });
  } catch (e: any) {
    console.error("/signed-url error:", e);
    const status = e?.message === "Missing token" ? 401 : 500;
    return NextResponse.json({ error: e?.message || "Internal server error" }, { status });
  }
}



===== app/favicon.ico =====
         (  F          (  n  00     (-  –           ¾F  (                                                           $   ]   º   º   ]   $                                           ò   ÿ   ÿ   ÿ   ÿ   ò                               8   à   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   à   8                  â   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   â              ¡   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ¡       #   ô   ÿ   ÿOOOÿ®®®ÿ«««ÿ«««ÿ«««ÿ«««ÿ­­­ÿgggÿ   ÿ   ÿ   ô   #   Y   ÿ   ÿ   ÿÿíííÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿıııÿ555ÿ   ÿ   ÿ   ÿ   Y   »   ÿ   ÿ   ÿ   ÿkkkÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ   ÿ   ÿ   ÿ   ÿ   »   »   ÿ   ÿ   ÿ   ÿ			ÿÍÍÍÿÿÿÿÿÿÿÿÿäääÿÿ   ÿ   ÿ   ÿ   ÿ   »   Y   ÿ   ÿ   ÿ   ÿ   ÿJJJÿıııÿÿÿÿÿkkkÿ   ÿ   ÿ   ÿ   ÿ   ÿ   Y   #   ô   ÿ   ÿ   ÿ   ÿÿ¶¶¶ÿÕÕÕÿ			ÿ   ÿ   ÿ   ÿ   ÿ   ô   #       ¡   ÿ   ÿ   ÿ   ÿ   ÿ111ÿDDDÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ¡              â   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   â                  8   à   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   à   8                               ò   ÿ   ÿ   ÿ   ÿ   ò                                           $   ]   º   º   ]   $                                                                                                                                                                                                                                                                                    (       @                                                                               ,   U      è   è      U   ,                                                                                      *   …   Ò   ù   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ù   Ò   …   *                                                                      –   ó   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ó   –                                                          Q   á   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   á   Q                                               r   û   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   û   r                                       r   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   r                               O   û   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   û   O                          ä   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ã                      —   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   —               (   õ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ô   '           †   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ888ÿ‹‹‹ÿˆˆˆÿˆˆˆÿˆˆˆÿˆˆˆÿˆˆˆÿˆˆˆÿˆˆˆÿˆˆˆÿˆˆˆÿˆˆˆÿˆˆˆÿˆˆˆÿ‰‰‰ÿ___ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   †          Ô   ÿ   ÿ   ÿ   ÿ   ÿ   ÿÿîîîÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿSSSÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   Ô      +   ú   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿhhhÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ®®®ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ú   +   T   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿÿËËËÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿôôôÿ,,,ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   T   ‚   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿGGGÿıııÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ      é   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ­­­ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿäääÿÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   é   é   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ+++ÿóóóÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿjjjÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   é      ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ‹‹‹ÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÌÌÌÿÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ‚   T   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿÿãããÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿıııÿIIIÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   T   +   ú   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿhhhÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ¯¯¯ÿÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ú   +      Ô   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿÿËËËÿÿÿÿÿÿÿÿÿôôôÿ,,,ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   Ô          †   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿGGGÿıııÿÿÿÿÿÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   †           '   ô   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ±±±ÿìììÿÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   õ   (               —   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ333ÿ___ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   —                      ã   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ä                          O   û   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   û   O                               r   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   r                                       r   û   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   û   r                                               Q   á   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   á   Q                                                          –   ó   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ó   –                                                                      *   …   Ò   ù   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ù   Ò   …   *                                                                                      ,   U      è   è      U   ,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               (   0   `           -                                                                                             	   (   L   j   ³   ø   ÷   ³   j   K   (   	                                                                                                                                          V       Ø   ø   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ø   Ø       U                                                                                                                      %   ‹   á   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   á   ‹   &                                                                                                      ‹   ï   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ï   ‹                                                                                          Q   Ü   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   Ü   R                                                                              Š   ş   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ş   Š                                                                     ­   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ­                                                             ¸   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ¸                                                     ®   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ®                                              Š   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   Š                                       P   ı   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ı   O                                  ß   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ß                              ‹   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ‹                       #   ñ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ñ   #                   Œ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ‹                  ä   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ$$$ÿhhhÿeeeÿeeeÿeeeÿeeeÿeeeÿeeeÿeeeÿeeeÿeeeÿeeeÿeeeÿeeeÿeeeÿeeeÿeeeÿeeeÿeeeÿeeeÿeeeÿeeeÿeeeÿPPPÿÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ä              U   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿÿëëëÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿsssÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   U           ¡   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿeeeÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÌÌÌÿÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ¡       	   Ú   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿÿÉÉÉÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿıııÿHHHÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   Ú   	   (   ù   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿEEEÿüüüÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ®®®ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ø   (   K   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿªªªÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿôôôÿ,,,ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   L   j   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ)))ÿòòòÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿŒŒŒÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   j   ´   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿˆˆˆÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿãããÿÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ³   ø   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿÿáááÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿiiiÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ø   ø   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿeeeÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿËËËÿÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ø   ³   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿÿÉÉÉÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿıııÿHHHÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ´   j   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿEEEÿüüüÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿ®®®ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   j   L   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿªªªÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿôôôÿ,,,ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   K   (   ø   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ)))ÿòòòÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿŒŒŒÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ù   (   	   Ú   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿˆˆˆÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿãããÿÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   Ú   	       ¡   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿÿáááÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿiiiÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ¡           U   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿeeeÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÿÌÌÌÿÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   U              ä   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿÿÉÉÉÿÿÿÿÿÿÿÿÿıııÿHHHÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ä                  ‹   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿEEEÿüüüÿÿÿÿÿ®®®ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   Œ                   #   ñ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ¬¬¬ÿûûûÿ,,,ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ñ   #                       ‹   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ222ÿ}}}ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ‹                              ß   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ß                                  O   ı   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ı   P                                       Š   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   Š                                              ®   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ®                                                     ¸   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ¸                                                             ­   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ­                                                                     Š   ş   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ş   Š                                                                              R   Ü   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   Ü   Q                                                                                          ‹   ï   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ï   ‹                                                                                                      &   ‹   á   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   á   ‹   %                                                                                                                      U       Ø   ø   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ÿ   ø   Ø       V                                                                                                                                          	   (   K   j   ³   ÷   ø   ³   j   L   (   	                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ‰PNG

   IHDR         \r¨f   sRGB ®Îé   8eXIfMM *    ‡i                                D"8s  IDATxí]	°Õ™n”]<QVA–èÄh$	ÊNŒ13*ˆq°ÂdªÄ©I¡ˆ˜D“L2“ª(Î(Ô˜2ÖÄ™ÑG	‹Áq_@å±ˆà†ŠxÈ›ï»Ğ¾{o÷½½ÓııUß{}»OŸå;çÿûôùÏ9İÂ‘d®(Dg Ğ8	èôN º]€î@ hx¥?v ÀNà3à=`;ğ6ğ.ğ&°àuâà  ±”6‰P©Ğ½€Á@ÿÃ RÓ PùiZqÊ^DNãà€wp¼Ø¼ĞXĞhĞ˜Hg@ÀÌ
:Ùâ|ğ5` p"@À'¼É²™s{ëpü*ğ2ÀŞ…Ä d Ò¯Œ–È|(0ø
0 à“>Kò
³xX¬6 IJÈ ¤C|?$KENØ}Ï“|ŠÂòµáàöh $	2 Ù|/§Â . Nz ’#¼ÃW€eÀ
à5€ã’ˆÜ¶ˆúà;Ày •¾ ñgàs©h^  IÄÈ DL(¢;¸8 ÒHjg€cH|x 1 ËR"Œa€ïôÓ• GÁÙ@…è9`/`%0èHÄ@jğ½~,° ÛK
Ÿ,t).ÎèI‘ˆDèT¦Oû)~º°Vìu$b èª›ĞU%¥7“ƒ¨›ù _É$b 8Aç×À€ßøJö3` 510wQñ?¤øvrğÑá:ü2şKÄ@ ¤øv*{%#í‚AZ€å’^(õÏ=ñ³g \ãÀWƒÛ€É!:àß,`à6ıÏ643:@’c.FÙŸ¤ğùä€u?Ğ<'áİ€ƒ€”_Üvp: É8Q¾›
IñÅ·p{3ÎóĞkHÈ¢ŒG¡¼•®cñÑ¼<62&‹
×2uCÁÿàÚòæ•­ßâ¤Tø3Ú
½ê€›…;î¼”ªd/~m€½.ø’XÆ@{äw.°ğ«d]G•Ú {lKÜàEbœÿı(P©RuMüTÛC›ÒÚÃÀdäï])¿Œ_Lmà=Äû=@bœÍ÷K€ÛGUkÙ^œUÓØÆØÖøš)1€È»gÕT¢ÂŠ¯°m`9Ú\Ú®³ÀQşÍ@ØÊÔıâ°–6ğ:ÚÕ^›w¬òï¸E—D¤Á ç	ü5°àºëÄFĞ,ßÜ
ğX"Òd€mğ<€nB~òì@´¸÷µt×tx‹»ü;ÚfŞ>ñ“ªíI8µˆ»¿8Ó¸C1Ûª$B¸•§e†©İ+ş’jl«ÜEZÃÇ& ©ÊS:â:Š6°möë´ÿ\G1¥ç`¢¨Å!“nl»lÃÆŠÉ^€Q`í·@OcÙSÆÄ@e¸Í·º¹ç¤qbªp•ÿãS†Ä@upšº±FÀD@å¿Ğ“¿º†¦Ğæ2@#À¹ÆõL3 £A’”$H2Ç _h¶FH#rq(íÿOàDƒò¤¬ˆ¨àrunGOWaêbŠ &–SgDñ3ÀEDçto§*Ç¤šú¡Ä9kŠİ~)¿•¡,$Â x¿RŸ1˜vàK áÀ9€DäU(ğw®&LEÒäê©»€S)¹é3ĞY8x8 $.i€(íŒÄK¬Å€YœìğaÈ]­—´À4”ôÇ€	c‰“®Å@3¸fà€ó•4Æ Æ¢„ÿĞ/*bàüş Çş˜$!I€~‡Ø7ÉB*-1`	o Ÿ º	‘$»àÇ¡D‹¾‰”L‰ˆûàòß êJ"’äÀOQ¢Ë)•ö2@#Ğx4‰"$e ¨ø·Iö8’àOiˆ8ø"İ ¼GäŞ8[xÄt<ñ.´´7&‚m&ØR^‹³tq÷ Ø•á.¾§ÅYÅ-2È ½d§ ûã*_Üà&d|j\™W¼b ãôGùö«â*gœ¯ £‘é‡ÄF4ã"IñŠØƒ´/ b1q€NÈğãÀY€Dˆp¼ŒÛ9îãpÑ}w\¯ ó‘Ô¤£“Ó1 j`€èOûŸî­xK=€ÑHñ÷ ÷A“ˆ1Ÿ#¾
D:U8jÀõıtù©ë$b bA||ØU¼Q¿ü26%ªÌ)1 Šè…_Àê¢³!~DÙàºæ• ¿à+b >A´Ü:]ÑE$ˆ£50òGDhRÑtèĞÁéİ»wRÉ)ğPÇ ‘èn$‘ 3ÜÖë@bS§Nu–,Yâ´jÕÊ²œç:»¡ôÜ;ÀáÀßó@£`Ç|ã–-[)“'OVıÙÕ†©sFxÚ®“âÛ¥øn}Í›7¯ üü³~ıúÆºº:»ŒÀQ—©J_¤ÎUKj8–q0xğàÆ;v4 Ì=[õhW=¾	İë	¤&·!e5Ë8hÑ¢Eãİwß]¤üüñá‡6öïß_õiW}şSZÚ?	¿/`Ÿ;vlã¾}û2 <±hÑ" »À§ĞAî¹‘¸ÜÕX,ã mÛ¶+V¬(©ü<¹wïŞÆ#F¨^íª×;“ÖşaHğc ûà”)SÊ*¿{aùòåpÊØc89(Ñ^€şö4&E¦ÛoÃ†®Wü/· uÆ=±^€ş*?{k^·_EíÇÅúúz¹íªgö† UI-‹è{WU*
œ:pû9.tÚ·o(/İºus>ûì3ç‰'^Rg€ßäÚGâÌI_D®‘»åÜ~~½ ¹­{øúÙ?N0‘7½SêØ.Æ×¸ÿ~?}/y]nA;êØ£‹³ã2 ]ñFOB2C?·_I­÷œ”[Ğ:°:Ú=#ÀOzKé-ã ˆÛÏ£ï%å´®İ?jĞşIÀ®†PÛ¯¤æ{NÊ-hUİÿt•:™œƒ˜øõ ,â ·ŸG×KÊ-hUÛç¢cƒhP7 ÿÎ¡Â˜Á@µn?¿\Ó-¸k×.¹ıˆ2ã:õú ğ`ÙáF„Û=ı-á V·_ÉG¿ç¤Ü‚Vé İõ}¢0 WIù­ªøFºıÊ­öóèsM‡rZÕ8pJ¸QÜ*@OK8ëöó³
rZ¥Ôİ–a, ßûwË ØSéW^y¥Ÿ‡¾.· 5íat7ÔØİ¤üÖTv#İ~7n­àA"¸üòËÕ+´£WøèpMÂÅ/ªhK8ˆÒíçgä´F/^„·«ÅŒÀM{e ì¨èR›|ú)qØë7İt“æ?8'àµ€KùíP~ºıî¹ç°ú\õırÚÑ> Ç·Uk ØeP÷ß|ë^xÇéöó³
‹/V/Àüvòô™¯ôå„ä¢*×pâvûù ¹­Ğ¾ÊŸ]JûË}óˆk8(•ˆÎÅÇÀÄ‰Ñ£GÇ—€OÌmÚ´q,X oúğ”òe.â˜^ ¡QxĞÓßp’tûùõä4^_ƒN—{à†¾øÅyÄ2 †s¤ÛÏÏ Ğ-Ø¹sgµsÛÌĞiêv‘”Z8
!~PJ?Œc€«ıîºë®À›|Æ] ®Ü½{·³zõê¸“Rüµ1pnãÔàzïí¥º¼tlpû9³fÍrºvíjTæ®¿şzß4*OÊLã‹~•øÑçÔ•3˜ƒ4İ~~¯r­;ÔmêxYŒ+üÀ€€¡¤íöó3 r­;Ômêx“4à÷Å:7]ÕqLš4)U·Ÿ!rú1”êuê6¿ìÕ$ÍÀ7›®èÀ8ºwïîÌ™3Ç¸|5Ï>?î\zé¥ÍOë·œëÍ†× ğø,ïE›ÅÀŒ3œš•©2¹¹å–[œººº2Wu:E¾‚´›¼^p.H1cJºtû]}õÕB˜uéÔSOu®ºŠ»ÉIc€O¥òÄ%ƒ  ÆAZ«ıüüü®kµ ‘ºD?Ç5 Ş@Q×À ÿé3Àwê+®¸"ıŒT™ÎSÀUŞ¥à13Àî?ûâ5 M'İ‹úŸ>pûşZµj•~fjÈ×ˆ×¡Ô‚n©¦±>× ğÿi5D¤[bf íÕ~a‹'·`Xc¹Ÿã -¼1ók¢›½ÿÄI«ıüŞ÷ı®kµ QºÅ¯|ókßMËé(92È@’t°ÉíçÇİ‚X-èL×“a€úN4€“qÜ'$f0@·@V„nA›Ü˜Yá½L9:â|/^sÇ ú—	¨Ó)0`êj¿°T\wİuZ-–ÄèîÂ¨\ 	@Ñ:¦±cítûùœ{È-èÇRb×û1%× ôI,Y%T‘Ûİ~‡‹rú1”ØõÂCŸ€,¼$–´*Ë€é«ıÊf<à¹0zş¥èhÕFü„û¦ ·Ÿ«ı|â€¯8Z-èCRü—¹Tg× ĞHRf€‹glYí–ª¹sçÊ-–Äp÷Ó'+Ãèî¶mµ_Ø’gÍÍ–îçC¿{ ô	òÃ’”ÈªÛÏÎ™3gÊ-èGR|×¹7`G€Şñ¥¡˜ƒ0U·Ÿ_ÙµZĞ¡Ø¯ŸD )À±ó\>¬»ıÊ—üĞ¹ıŠõz N–¤Ä@Öİ~~´Ê-èÇP¬×{rs€¿´@¬<—œ›|.]ºÔ¸|”Îm|gûõëç¬_¿Şyå•WâKD1—bàM½”¢%¡s\“·Ÿ¥rú1Ëõnì\–Æ’„"-É İ`.4æÛ~%3™àI}[0A²$µ“= -Ò>BH"G®Û^r„­<ÂEBGİi Ú%”˜’9Ì@^İ~~@«ıŠüú1Üì€†@’ tû-[¶ÌèÏ{%@CÙ$ğmAgüøñÎš5kÊ†Ñ…ÈøœŠ/åŒOÿˆlßäÓ¿„áBĞ@.X°À±uäp¥Oüî6œ—x²9MPn¿`ß·o_§¾¾^nÁ`t…
¥§(úª»™ƒ\rûùsÆAÒyóæéÛ‚şT…¡@h
ƒE0lØ0çÎ;ïtÚµÓ˜kÆ¸N ¡¡ÁYµjUà
S#ì|^ã½º- |¢İpÃN—.…­ØŞ¥`×^{­zLñ6ƒƒ4 ŸÄ›†bç¨öe—]&"ªd€sÎœ9UŞ¥àU0ğ!ÀÁ*nPĞ*`—ÿæ›oÖ¨v•¼¹Ái8GåşÔÿhh ØmœŠÍËÀäÉ“sÏ=×{JÇU0ÀÕ‚óçÏwZ·æş’ˆø”ƒ€ì›ö8bEzôèá,Y²Dïş![CŸ>}œ7:k×®“noÆÀfö >jvR?#b€ƒXˆ(¶üFÃAT¾FÕÕióêˆ[Á{ì°zvÄç>º¡C‡Êía+[0B2Dµœ=€íG~ë(
øÄºñÆÕõ‚LO×\sÜ‚>"8|‹`[)
&Lp8ø'‰–öäŒ”Óí4 oGeÎ#£ÛÀlÙ’_\“DÍ€Ü‚‘2ZØl¢Üi´9ŒtäÈ‘9f Ş¢Ë-¿œ¼‹=€‡YÌyˆn?uQã¯}XÍ¬ÍsAïi >=ŒĞ1æ=RÉí+à +­Ü‚¡¸.2 šŠKì«·ßôéÓCÆ¢Ûƒ20hĞ ‡Ë«%53À5@…MA¹%˜¦×Ì£ãÈí‚¼·j[õä9Î;¸û _(¯ú§¿µ0ÀÕ~rûÕÂ\¸{ômÁPüÜÿ®x#TT9¾™n?¾Êí—N# á•×¥&î}× ¬¯)
İTVL¯!¸ßÔjÁªë`ïp ß8@RrûUAVŒAå¬šÜ=¸ã-Şå€÷pLHª`@n¿*ÈŠ1¨Ü‚U“Ëõ?}w ]ìH2@·ß´iÓ†V°¸ [Ë¯%àôÿ‚ëß5 8±)Ğ­
T`€›|rZbZ-¸.Ö!da+@× ğÎçßó€Zígf[0p½¼æ†ô ä¤ I´Égr¸$· o%PÇ_rCyÀVœ|ß½ ÿ¥à"mòYšÎÊ-è[ lÚÄk xAã ø“Û¯9]¢[pÒ¤IåÈ¨¬pP“ÇÏk ŠºFeÙÌÈígHEødƒnAm"Z–$õ5}„›‚zå8üéô2røX›|– ÅàSÜ»w¯³råJƒs™JÖ~T›fşz{ ÌÍ« ÷xĞj?jµàQ•Eİnò ğjsÀùÁ|GxĞ·ı<dXt(·àQ•Eİ.¬p¯47 Üğ)÷¢ş;…Ïysµ_«V­D‡…È-XTiÔí¢ı?› †~¼è–œÿÛÏî ·`Qı=Vô?šòú^à
€‚¹ºı–.]ª|XŞ
ômÁB~€¿?ŠÆøJõ ŞD —·äüÜ~Ùh rê‘óÿ©ÛERªÀ…Aİ€óŠBæìİ~wÜq‡Ó¾}ûœ•<›Å•[Ğ¹5ûdóÚ-Õ`˜5 ?Kqİ~l4’ì0@·à)§œ’/I‚®(¼œà‡Ø‹ü…¥nÎê9¹ı²Y³4èœ!˜CÙˆ2×—*w9ÀÀGKİõsî&Ÿrûe³¦súé¶? 6Ù8JÊ |(òuwOä´d°&K)‡nA¾Ê?RšÒn@7,·º8Á=‘õÿrûe½†•nÁM›69k×òM7óÂéı·J•´R€]†e¥nÊê9¹ı²Z³Ååâ /?á“o>ŒÒó•¾¤”rzrÒÀ óó`åöóV{ö»uëæ4448«V­Êra÷ p³ îõQRZ”<{ädK.F9•½#~Tâ¾ûîs.¾øâìN%*Ë ÀğáÃuë8G&“²¥ì/W:*x%á{Ã}@¦ »‚lõõõNc#çAIòÀÀ±Ç›õiŞ÷£Ë*?ëØ¯À0}€g€ãùC"Ä€pÛ¯³€Šßû¨4è–’Ò(bÀ8€_QùY” €áîr7'€—ˆ`·ÿî ùj ¸6à… *Œ©3ÀWögƒä"¨àl¢¡Âˆ1:ì±Sg}%È  	¹¥P?÷„ş‹1`›£¯ÉYĞ ãâ"‹‚Dª0b@¤Æ İö”Ÿ9¬¦Àğı¾[tá‰F1À‡ôp`kĞ\UÓ`œÜRø·A#W81 e`)RÛZMŠÕö ÷€[uæ‰F0ğ	rq.ÀÕ¥Ú #^ğ=C"Ä€9P'«R~f½– ï
pn€zdC"Òe ¦§?³\K€÷½¨@&$b }jzú3Ûµö x/{èÄ1 Ra€#ÿ|÷çÆŸUK­= &Ä^€æTM¹n‘2À9ÿ5)?s¦Àû{O'ó‡DˆDà’ßo [kMÕoK0¿xÿŒ ÜTd‚_@]b ræ ÆGÃÄ¶À´; «€¯ò‡DˆDàêÜ1ÀgaRÛ`ÚÜ'`0ˆÂ  ‰>\ë/ù„ñ½fĞùƒøñ÷„Å€ˆß!fn÷Z¢|bŸ†ÜğU .t®åà¤ŸÑÀÚrª9Å+€›ı‘­€±î	ıb rnEŒDk”= æé8àÀÙü!b RClã€PŞEÙ`¼ÜŒK†'~ß@‰ Ë}*°!`ø@Á¢6 Lô ;À	$b@DÃÀ?#šÈgŞFı
àµV”ˆ1vıÇ;ÃEsôİQ¹›ÇÌ=É®ö4¿ ßb@TÅÀn„ş!¹ò3q¼0^ÊV€ã c ‰µ1ğÜ¶´¶[ıïŠëÀM¹=8Iˆİ‰Õ1@Ú…@Cu··`N¸oÀã WJÄ€Æ WúÑåÇe÷±Iœ¯ n¦¹Nàmà¯€¸ÆÜ´ô_d(Ä4`EÜ…IÂ °¯œ"ÌµË1 *3ğ+\şEå Ñ\MâÀÍ)g	rÁ¦
»Œè¿8š>õ¿pô?vIÒ °0€Ç€~ü!b ˆ­øÅ$'Ó%"I¿“¿RıÀi1 0°‡? S~&Ô Ór…ä’Æ€¤{ nô_˜ÄÀÈÌLà?’ÎT€eäÔÆÀ7ùC"rÎÀOQ~"qIË ° O 8?$b §Ü‹rÿ#@×_â’v¼JÌ™‚£/¹é3ğ'dá/ÈÖ÷W[¤¤›ço'Nüğlóú-2Î Ûüå@jÊO~Óî0”À2` HÄ@ÆØ„òĞ+–ª¤İpOB® ŞuOè¿È(lãS€Ô•Ÿü¦9Èô½ò~ğcß:x/èXd„.ğù°Æ”ò˜d ÈÉVày@F $H2Å •Ÿïü+M*•i€Ül8O@F $H2Á •Ÿå®2­4& r´POÀ´Ö¢üÔÂ€ûä7NùYS ó¶ øÀYƒ1`ğã;ÿJS3n² g['‘@W@"la`32Ên?'ûHB2p
îhÄm€mu ‰“×j@F@˜ÜV ²­Z!¦¿xIä”ÉÿH®y™Ñ±)üù>ÀåZ!6 ºà”aÎ`äş‚¦ÌdDV$9f€ëù	pM¿6»I¨!LG:\LdrwPyË~ıPá§%Ôæ•L3Æá7çTKÑÄAm€mo|³6©Ÿ	3Ğé-Òh J3¿¼?67 á¶yr¶”"€ûşàgÈÎ4. $±1À÷ı_¼[*Š¸&¸¤˜S/õdq´Îìãä‰ÁCŞâh Š3¿¼>Š6Å¶%±€¶Èã\€#´RZq¦ğ=lK|Å”XÆÀXäWSˆe j5 /¡ıĞÓ$±˜:äıv@½‚ †€Î8Ğ×d„1(‡z2~Fà)´ùö3¢ôÍ‹ÁŞÀl€®C¿† ëùâè#´‰›í=².\Lt? %Ñ N$9b %Ê:àşƒ2ùä€u	 É1|-˜	ldòÁ÷œœt $b À@?ü¥·@† »FàcÔïÏ^€D”d€[9ıà zÙà€ŠÏ:
HÄ@ ¾ŒP2v )~ ¦®@•àüïŸz5°Ç|€úÒ¿R«ÖµªàÁ|`# W39Ø‚ºá<î"-±0Àï\<ìdÒå€uÀoGLz 1œGp°à—e’å€¯d‹ .øjHÄ@jôFÊ3€•@ c{s<ÿùJ&	É@‹÷ëöb¸ÙÀw‹  ²§ ©nÁµàvğœ²û< ‰ˆ€ˆˆ,M;œû*p>p!0hHüà{=•»ğüxà]IÄÈ DLh™èÚâ<'¡Œh8Ç@V Á#ïã˜Jÿ°àfû IŒÈ ÄHn…¨ûãWŸ}àNÆt[uò$Ÿ¢°›§å ş@’ 2 	’]&)† #€3ˆ“,	=%¯TôÕÀkÀ&à  I‰€”ˆ÷I¶®Ó³ğ Ù[8	è	´L–]È]tïTğgõÀ6à-@b2 U†OVºã: A?€¯} .iî|	àxCœÂ÷rvßw; ÎÀ#ê>éi 8_b82 †WP€ìÑõè  {'n¯áÓ8ğz;€Æ¤yİsŸ œÃ@¥¦¼P¡·o|ÂSùih $3ğÿ@ß¹jìŠá    IEND®B`‚

===== app/feed/page.tsx =====
// apps/web/app/feed/page.tsx
"use client";

import { useEffect, useState } from "react";
import { useAuth } from "@/hooks/useAuth";
import { getMyVideos } from "@/lib/api";
import VideoCard from "@/components/VideoCard";

export default function FeedPage() {
  const { user, loading } = useAuth();
  const [videos, setVideos] = useState<any[]>([]);
  const [busy, setBusy] = useState(false);

  useEffect(() => {
    (async () => {
      if (loading || !user) return;
      setBusy(true);
      try {
        const data = await getMyVideos("/api/videos");
        setVideos(data?.videos ?? []);
      } catch (e) {
        console.error("Feed load error:", e);
        setVideos([]);
      } finally {
        setBusy(false);
      }
    })();
  }, [loading, user]);

  if (loading) return <div className="p-6">Loadingâ€¦</div>;
  if (!user) return <div className="p-6">Please log in to view your feed.</div>;
  if (busy) return <div className="p-6">Loading videosâ€¦</div>;
  if (videos.length === 0) return <div className="p-6">No videos yet.</div>;

  return (
    <div className="grid gap-4 sm:grid-cols-2 lg:grid-cols-3 p-6">
      {videos.map((v) => (
        <VideoCard key={v.id} video={v} onUpdated={() => {}} />
      ))}
    </div>
  );
}



===== app/forbidden.tsx =====
// apps/web/app/forbidden.tsx
export default function ForbiddenPage() {
  return (
    <div className="flex flex-col items-center justify-center h-screen text-center">
      <h1 className="text-5xl font-bold mb-4">403</h1>
      <p className="text-lg">You are not authorized to view this video.</p>
    </div>
  );
}



===== app/globals.css =====
@import "tailwindcss";

:root {
  --background: #ffffff;
  --foreground: #171717;
}

@theme inline {
  --color-background: var(--background);
  --color-foreground: var(--foreground);
  --font-sans: var(--font-geist-sans);
  --font-mono: var(--font-geist-mono);
}

@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}

body {
  background: var(--background);
  color: var(--foreground);
  font-family: Arial, Helvetica, sans-serif;
}


===== app/layout.tsx =====
import "./globals.css";
import ClientAuthProvider from "@/components/ClientAuthProvider";

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <body>
        <ClientAuthProvider>
          {children}
        </ClientAuthProvider>
      </body>
    </html>
  );
}



===== app/login/page.tsx =====
"use client";

import { useRouter } from "next/navigation";
import { useState } from "react";
import { auth } from "@/lib/firebase";
import { signInWithEmailAndPassword } from "firebase/auth";

export default function LoginPage() {
  const router = useRouter();
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [error, setError] = useState("");

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError("");

    try {
      await signInWithEmailAndPassword(auth, email, password);
      router.push("/profile");
    } catch (err: any) {
      setError(err.message);
    }
  };

  return (
    <div className="flex flex-col items-center justify-center min-h-screen">
      <h1 className="text-2xl font-bold mb-4">Login</h1>
      <form onSubmit={handleSubmit} className="flex flex-col gap-2 w-64">
        <input
          type="email"
          placeholder="Email"
          className="border px-3 py-2 rounded"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
        />
        <input
          type="password"
          placeholder="Password"
          className="border px-3 py-2 rounded"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
        />
        {error && <p className="text-red-500 text-sm">{error}</p>}
        <button
          type="submit"
          className="bg-green-500 text-white py-2 rounded hover:bg-green-600"
        >
          Login
        </button>
      </form>
    </div>
  );
}



===== app/not-found.tsx =====
// apps/web/app/not-found.tsx
export default function NotFoundPage() {
  return (
    <div className="flex flex-col items-center justify-center h-screen text-center">
      <h1 className="text-5xl font-bold mb-4">404</h1>
      <p className="text-lg">This video could not be found.</p>
    </div>
  );
}



===== app/page.tsx =====
// apps/web/app/page.tsx
"use client";

import { useEffect, useState } from "react";
import PageLayout from "@/components/PageLayout";
import VideoCard from "@/components/VideoCard";
import { useAuth } from "@/hooks/useAuth";
import { getMyVideos } from "@/lib/api";

export default function HomePage() {
  const { user, loading } = useAuth();
  const [videos, setVideos] = useState<any[]>([]);

  useEffect(() => {
    async function fetchVideos() {
      if (loading || !user) return;
      const data = await getMyVideos("/api/videos");
      setVideos(data?.videos ?? []);
    }
    fetchVideos();
  }, [loading, user]);

  return (
    <PageLayout>
      <h1 className="text-2xl font-bold mb-4">Latest Videos</h1>
      {!user ? (
        <p className="text-gray-600">Please log in to see your latest videos.</p>
      ) : (
        <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
          {videos.map((video) => (
            <VideoCard key={video.id} video={video} onUpdated={() => {}} />
          ))}
        </div>
      )}
    </PageLayout>
  );
}



===== app/profile/page.tsx =====
"use client";

import { useEffect, useState } from "react";
import { getMyVideos } from "@/lib/api";
import VideoCard from "@/components/VideoCard";
import ProfileHeader from "./ProfileHeader";

export default function ProfilePage() {
  const [videos, setVideos] = useState<any[]>([]);
  const [page, setPage] = useState(1);
  const [hasMore, setHasMore] = useState(true);
  const [sort, setSort] = useState("created_at");
  const [filter, setFilter] = useState("");
  const [showTrashed, setShowTrashed] = useState(false);

  const load = async (reset = false) => {
    const q = new URLSearchParams();
    q.set("page", reset ? "1" : String(page));
    q.set("limit", "9");
    q.set("sort", sort);
    if (filter) q.set("title", filter);

    const endpoint = showTrashed
      ? "/api/videos/trash"
      : `/api/videos?${q.toString()}`;

    const data = await getMyVideos(endpoint);
    const list = data?.videos ?? [];

    if (reset) {
      setVideos(list);
      setPage(2);
      setHasMore(list.length > 0);
    } else {
      setVideos((prev) => [...prev, ...list]);
      setPage((p) => p + 1);
      setHasMore(list.length > 0);
    }
  };

  useEffect(() => {
    load(true);
  }, [sort, filter, showTrashed]);

  return (
    <div className="p-6">
      <ProfileHeader /> {/* ğŸ‘ˆ Logout button now visible */}

      <div className="flex gap-4 mb-4">
        <input
          placeholder="Filter by title"
          value={filter}
          onChange={(e) => setFilter(e.target.value)}
          className="border px-2 py-1 rounded"
        />
        <select
          value={sort}
          onChange={(e) => setSort(e.target.value)}
          className="border px-2 py-1 rounded"
        >
          <option value="created_at">Sort by Date</option>
          <option value="title">Sort by Title</option>
        </select>
        <label className="flex items-center gap-1 text-sm">
          <input
            type="checkbox"
            checked={showTrashed}
            onChange={(e) => setShowTrashed(e.target.checked)}
          />
          Show trashed
        </label>
      </div>

      {videos.length === 0 ? (
        <p>No videos found.</p>
      ) : (
        <div className="grid gap-4 sm:grid-cols-2 lg:grid-cols-3">
          {videos.map((v) => (
            <VideoCard key={v.id} video={v} onUpdated={() => load(true)} />
          ))}
        </div>
      )}

      {hasMore && (
        <div className="mt-4">
          <button
            onClick={() => load()}
            className="px-4 py-2 bg-blue-600 text-white rounded"
          >
            Load More
          </button>
        </div>
      )}
    </div>
  );
}



===== app/profile/ProfileHeader.tsx =====
"use client";

import { signOut } from "firebase/auth";
import { auth } from "@/lib/firebase";

export default function ProfileHeader() {
  const handleLogout = async () => {
    await signOut(auth);
    // Redirect to login after logout
    window.location.href = "/login";
  };

  return (
    <div className="flex justify-between items-center mb-4">
      <h2 className="text-2xl font-bold">My Videos</h2>
      <button
        onClick={handleLogout}
        className="px-3 py-1 bg-red-600 text-white rounded hover:bg-red-700"
      >
        Logout
      </button>
    </div>
  );
}



===== app/signup/page.tsx =====
"use client";

import { useRouter } from "next/navigation";
import { useState } from "react";
import { auth } from "@/lib/firebase";
import { createUserWithEmailAndPassword } from "firebase/auth";

export default function SignupPage() {
  const router = useRouter();
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [error, setError] = useState("");

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError("");

    try {
      await createUserWithEmailAndPassword(auth, email, password);
      router.push("/profile");
    } catch (err: any) {
      if (err.code === "auth/email-already-in-use") {
        setError("Email already registered. Please login instead.");
      } else {
        setError(err.message);
      }
    }
  };

  return (
    <div className="flex flex-col items-center justify-center min-h-screen">
      <h1 className="text-2xl font-bold mb-4">Sign Up</h1>
      <form onSubmit={handleSubmit} className="flex flex-col gap-2 w-64">
        <input
          type="email"
          placeholder="Email"
          className="border px-3 py-2 rounded"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
        />
        <input
          type="password"
          placeholder="Password"
          className="border px-3 py-2 rounded"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
        />
        {error && <p className="text-red-500 text-sm">{error}</p>}
        <button
          type="submit"
          className="bg-blue-500 text-white py-2 rounded hover:bg-blue-600"
        >
          Sign Up
        </button>
      </form>
    </div>
  );
}



===== app/upload/page.tsx =====
"use client";

import React, { useState } from "react";
import { useAuth } from "@/hooks/useAuth";
import PageLayout from "@/components/PageLayout";
import toast, { Toaster } from "react-hot-toast";

export default function UploadPage() {
  const { user } = useAuth();
  const [file, setFile] = useState<File | null>(null);
  const [title, setTitle] = useState("");
  const [loading, setLoading] = useState(false);

  const handleUpload = async () => {
    if (loading) return;
    if (!user) return toast.error("You must be logged in to upload.");
    if (!file) return toast.error("Please choose a video file.");

    setLoading(true);
    try {
      const form = new FormData();
      form.append("file", file);
      form.append("title", title);
      form.append("userId", user.uid);
      form.append("userEmail", user.email || "");

      const res = await fetch("/api/upload", { method: "POST", body: form });
      const json = await res.json();

      if (!res.ok) throw new Error(json.error || "Upload failed");

      toast.success("Video uploaded!");
      window.location.href = "/profile";
    } catch (e: any) {
      toast.error(e.message || "Upload failed");
    } finally {
      setLoading(false);
    }
  };

  return (
    <PageLayout>
      <Toaster position="top-right" />
      <div className="p-6 max-w-xl mx-auto">
        <h1 className="text-2xl font-bold mb-4">Upload Video</h1>

        <input
          type="text"
          placeholder="Video title (optional)"
          value={title}
          onChange={(e) => setTitle(e.target.value)}
          className="border p-2 mb-3 w-full"
        />

        <input
          type="file"
          accept="video/*"
          onChange={(e) => setFile(e.target.files?.[0] ?? null)}
          className="mb-4"
        />

        <div className="flex gap-2">
          <button
            onClick={handleUpload}
            disabled={loading}
            className="px-4 py-2 bg-indigo-600 text-white rounded disabled:opacity-60"
          >
            {loading ? "Uploading..." : "Upload"}
          </button>
        </div>
      </div>
    </PageLayout>
  );
}



===== app/videos/trash/page.tsx =====
"use client";

import { useEffect, useState } from "react";
import { getMyVideos, restoreVideo, deleteVideo } from "@/lib/api";

export default function TrashPage() {
  const [videos, setVideos] = useState<any[]>([]);
  const [busy, setBusy] = useState<string | null>(null);

  const load = async () => {
    const data = await getMyVideos("/api/videos/trash");
    setVideos(data?.videos ?? []); // expect { videos: [...] }
  };

  useEffect(() => {
    load();
  }, []);

  const handleRestore = async (id: string) => {
    if (!confirm("Restore this video to My Videos?")) return;
    setBusy(id);
    try {
      await restoreVideo(id); // PATCH { action: "restore" }
      await load();
    } finally {
      setBusy(null);
    }
  };

  const handleDelete = async (id: string) => {
    if (!confirm("Permanently delete this video?")) return;
    setBusy(id);
    try {
      await deleteVideo(id); // PATCH { action: "delete" }
      await load();
    } finally {
      setBusy(null);
    }
  };

  return (
    <div className="p-6">
      <h1 className="text-2xl font-bold mb-4">Trash</h1>
      {videos.length === 0 ? (
        <p>No trashed videos.</p>
      ) : (
        <ul className="space-y-4">
          {videos.map((v) => (
            <li key={v.id} className="border rounded p-4 flex justify-between items-center">
              <span>{v.title || "Untitled"}</span>
              <div className="flex gap-2">
                <button
                  onClick={() => handleRestore(v.id)}
                  disabled={busy === v.id}
                  className="px-3 py-1 bg-green-600 text-white rounded"
                >
                  Restore
                </button>
                <button
                  onClick={() => handleDelete(v.id)}
                  disabled={busy === v.id}
                  className="px-3 py-1 bg-red-600 text-white rounded"
                >
                  Delete Permanently
                </button>
              </div>
            </li>
          ))}
        </ul>
      )}
    </div>
  );
}



===== app/videos/[id]/page.tsx =====
import { createClient } from "@supabase/supabase-js";
import type { Metadata } from "next";
import WatchClient from "./WatchClient";

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!,
  { auth: { persistSession: false } }
);

// --- SEO metadata ---
export async function generateMetadata(
  { params }: { params: Promise<{ id: string }> }
): Promise<Metadata> {
  const { id } = await params;

  const { data: video } = await supabase
    .from("videos")
    .select("title, description, thumbnail_url, deleted_at, uploaded_at, duration")
    .eq("id", id)
    .maybeSingle();

  if (!video || video.deleted_at) {
    return {
      title: "Video not found",
      description: "This video could not be found.",
      alternates: { canonical: `https://your-domain.com/videos/${id}` },
      openGraph: {
        title: "Video not found",
        description: "This video could not be found.",
        type: "website",
      },
      twitter: {
        card: "summary",
        title: "Video not found",
        description: "This video could not be found.",
      },
    };
  }

  // Sign thumbnail for OG/Twitter
  let ogImage: string | undefined;
  if (video.thumbnail_url) {
    const key = video.thumbnail_url.startsWith("/")
      ? video.thumbnail_url.slice(1)
      : video.thumbnail_url;
    const { data: signed } = await supabase.storage
      .from("videos")
      .createSignedUrl(key, 60 * 60);
    ogImage = signed?.signedUrl;
  }

  const title = video.title ?? "Chitradhara video";
  const description = video.description ?? "Watch this video on Chitradhara.";

  return {
    title,
    description,
    alternates: { canonical: `https://your-domain.com/videos/${id}` },
    openGraph: {
      title,
      description,
      type: "video.other",
      images: ogImage ? [{ url: ogImage }] : undefined,
    },
    twitter: {
      card: ogImage ? "summary_large_image" : "summary",
      title,
      description,
      images: ogImage ? [ogImage] : undefined,
    },
  };
}

// --- Default page component ---
export default async function WatchPage({
  params,
}: {
  params: Promise<{ id: string }>;
}) {
  const { id } = await params;

  // Fetch video info
  const { data: video } = await supabase
    .from("videos")
    .select("title, description, file_path, url, deleted_at, thumbnail_url, uploaded_at, duration")
    .eq("id", id)
    .maybeSingle();

  if (!video || video.deleted_at) {
    return (
      <div className="p-6">
        <h1 className="text-2xl font-bold mb-4">Video not found</h1>
      </div>
    );
  }

  // Signed video URL
  let signedUrl: string | null = null;
  const storageKey = video.file_path ?? video.url ?? null;
  if (storageKey) {
    const cleanKey = storageKey.startsWith("/") ? storageKey.slice(1) : storageKey;
    const { data: signed } = await supabase.storage
      .from("videos")
      .createSignedUrl(cleanKey, 60 * 60);
    signedUrl = signed?.signedUrl ?? null;
  }

  // Signed thumbnail
  let thumbnail: string | null = null;
  if (video.thumbnail_url) {
    const cleanThumb = video.thumbnail_url.startsWith("/")
      ? video.thumbnail_url.slice(1)
      : video.thumbnail_url;
    const { data: signed } = await supabase.storage
      .from("videos")
      .createSignedUrl(cleanThumb, 60 * 60);
    thumbnail = signed?.signedUrl ?? null;
  }

  return (
    <div className="p-6 space-y-4">
      <h1 className="text-2xl font-bold">{video.title ?? "Untitled video"}</h1>
      {video.description && <p className="text-gray-600">{video.description}</p>}
      {thumbnail && (
        <img
          src={thumbnail}
          alt="Thumbnail"
          className="w-full max-w-md rounded shadow"
        />
      )}
      <div>
        <WatchClient id={id} signedUrl={signedUrl} />
      </div>

      {/* âœ… JSON-LD VideoObject for SEO */}
      <script
        type="application/ld+json"
        dangerouslySetInnerHTML={{
          __html: JSON.stringify({
            "@context": "https://schema.org",
            "@type": "VideoObject",
            name: video.title ?? "Chitradhara video",
            description: video.description ?? "Watch this video on Chitradhara.",
            thumbnailUrl: thumbnail ? [thumbnail] : [],
            uploadDate: video.uploaded_at ?? new Date().toISOString(),
            duration: video.duration ?? "PT0M",
            contentUrl: signedUrl ?? undefined,
            embedUrl: `https://your-domain.com/videos/${id}`,
          }),
        }}
      />
    </div>
  );
}



===== app/videos/[id]/WatchClient.tsx =====
// apps/web/app/videos/[id]/WatchClient.tsx
"use client";

import React, { useRef, useState, useEffect, useCallback } from "react";
import { getFreshSignedUrl } from "@/lib/api";

interface Props {
  id: string;
}

export default function WatchClient({ id }: Props) {
  const videoRef = useRef<HTMLVideoElement | null>(null);
  const [src, setSrc] = useState<string | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [retryCount, setRetryCount] = useState(0);
  const MAX_RETRIES = 2;

  const fetchSignedUrl = useCallback(async () => {
    setLoading(true);
    setError(null);
    try {
      const json = await getFreshSignedUrl(id); // includes Bearer token via api.ts
      const signed = json.signed_url ?? json.url ?? json.signedUrl ?? null;
      if (!signed) {
        setError("No signed URL returned.");
        return;
      }

      setSrc(signed);
      const v = videoRef.current;
      if (v) {
        v.pause();
        v.src = signed;
        v.load();
        v.play().catch(() => {});
      }
    } catch (e: any) {
      // map common error strings to friendly messages
      const msg = String(e?.message || "Unknown error");
      if (/Unauthorized/i.test(msg)) setError("You must sign in to view this video (401).");
      else if (/Forbidden/i.test(msg)) setError("Access forbidden (403). You don't have permission to view this video.");
      else if (/Not found/i.test(msg)) setError("Video not found (404).");
      else setError(msg);
    } finally {
      setLoading(false);
    }
  }, [id]);

  useEffect(() => {
    fetchSignedUrl();
  }, [fetchSignedUrl]);

  const onVideoError = async () => {
    if (retryCount >= MAX_RETRIES) {
      setError("Playback error and retry limit reached.");
      return;
    }
    setRetryCount((c) => c + 1);
    await fetchSignedUrl();
  };

  if (loading) return <div className="w-full max-w-3xl h-64 bg-gray-200 animate-pulse rounded" />;

  if (error)
    return (
      <div className="p-4">
        <p className="text-red-500">{error}</p>
        <div className="mt-2">
          <button
            onClick={() => {
              setRetryCount(0);
              fetchSignedUrl();
            }}
            className="px-3 py-1 bg-blue-600 text-white rounded"
          >
            Retry
          </button>
        </div>
      </div>
    );

  return (
    <div>
      {src ? (
        <video
          ref={videoRef}
          src={src}
          controls
          className="w-full max-w-3xl rounded shadow"
          onError={onVideoError}
        />
      ) : (
        <p className="text-gray-500">No video source available.</p>
      )}
    </div>
  );
}



===== components/AuthProvider.tsx =====
"use client";

import React, { ReactNode, useEffect, useState, useMemo } from "react";
import { onAuthStateChanged, getAuth, User } from "firebase/auth";
import { app } from "@/lib/firebase"; // âœ… fixed alias

type AuthContextType = {
  user: User | null;
  loading: boolean;
};

export const AuthContext = React.createContext<AuthContextType>({
  user: null,
  loading: true,
});

export default function AuthProvider({ children }: { children: ReactNode }) {
  const [user, setUser] = useState<User | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const auth = getAuth(app);
    const unsubscribe = onAuthStateChanged(auth, (firebaseUser) => {
      setUser(firebaseUser);
      setLoading(false);
      // console.log("Auth state changed:", firebaseUser); // ğŸ” Debug if needed
    });

    return () => {
      unsubscribe();
    };
  }, []);

  const contextValue = useMemo(
    () => ({ user, loading }),
    [user, loading]
  );

  return (
    <AuthContext.Provider value={contextValue}>
      {children}
    </AuthContext.Provider>
  );
}



===== components/ClientAuthProvider.tsx =====
"use client";

import { useEffect } from "react";
import { onAuthStateChanged } from "firebase/auth";
import { auth } from "@/lib/firebase";

export default function ClientAuthProvider({ children }: { children: React.ReactNode }) {
  useEffect(() => {
    const unsub = onAuthStateChanged(auth, async (user) => {
      if (process.env.NODE_ENV === "development") {
        // @ts-ignore
        window.__TEST_ID_TOKEN__ = user ? await user.getIdToken() : null;
      }
    });
    return () => unsub();
  }, []);

  return <>{children}</>;
}



===== components/Hello.tsx =====
export default function Hello(props: { name: string }) {
  return <h2>Hello, {props.name}! ğŸ‘‹</h2>;
}



===== components/Navbar.tsx =====
"use client";

import Link from "next/link";
import { useEffect, useState } from "react";
import { auth } from "@/lib/firebase";
import { signOut, onAuthStateChanged, User } from "firebase/auth";

export default function Navbar() {
  const [user, setUser] = useState<User | null>(null);

  useEffect(() => {
    const unsubscribe = onAuthStateChanged(auth, (currentUser) => {
      setUser(currentUser);
    });
    return () => unsubscribe();
  }, []);

  const handleLogout = async () => {
    await signOut(auth);
    alert("ğŸ‘‹ Logged out!");
  };

  return (
    <nav className="flex justify-between items-center px-6 py-4 bg-indigo-600 text-white">
      {/* Logo / Title */}
      <Link href="/" className="text-xl font-bold hover:underline">
        Chitradhara ğŸ¥
      </Link>

      {/* Navigation Links */}
      <div className="flex items-center gap-4">
        <Link href="/about" className="hover:underline">
          About
        </Link>

        {!user ? (
          <>
            <Link href="/login" className="hover:underline">
              Login
            </Link>
            <Link href="/signup" className="hover:underline">
              Sign Up
            </Link>
          </>
        ) : (
          <>
            <span className="text-sm text-gray-200">
              {user.email}
            </span>
            <button
              onClick={handleLogout}
              className="bg-red-500 px-3 py-1 rounded-lg hover:bg-red-600"
            >
              Logout
            </button>
          </>
        )}
      </div>
    </nav>
  );
}



===== components/PageLayout.tsx =====
"use client";

import Link from "next/link";
import React from "react";

export default function Layout({ children }: { children: React.ReactNode }) {
  return (
    <div className="min-h-screen flex flex-col">
      <header className="border-b">
        <nav className="max-w-6xl mx-auto p-4 flex items-center gap-4">
          <Link href="/" className="font-bold text-lg">Chitradhara ğŸ¥</Link>
          <div className="ml-auto flex items-center gap-4">
            <Link href="/feed" className="hover:underline">Feed</Link>
            <Link href="/profile" className="hover:underline">Profile</Link>
            <Link href="/videos/trash" className="hover:underline">Trash</Link>
            <Link href="/upload" className="hover:underline">Upload</Link>
          </div>
        </nav>
      </header>
      <main className="flex-1">{children}</main>
      <footer className="border-t">
        <div className="max-w-6xl mx-auto p-4 text-sm text-gray-500">
          Â© {new Date().getFullYear()} Chitradhara
        </div>
      </footer>
    </div>
  );
}



===== components/RequireAuth.tsx =====
"use client";

import { ReactNode, useEffect } from "react";
import { redirect } from "next/navigation";
import { useAuth } from "@/hooks/useAuth"; // âœ… fixed alias â€” no /src in path

/**
 * Wraps any page/component that should only be visible to loggedâ€‘in users.
 * If no user is found and loading is complete, redirects to /login.
 */
export default function RequireAuth({ children }: { children: ReactNode }) {
  const { user, loading } = useAuth();

  useEffect(() => {
    if (!loading && !user) {
      redirect("/login");
    }
  }, [loading, user]);

  // While checking auth state, render nothing (or a loader if you want)
  if (loading) {
    return (
      <div className="flex items-center justify-center h-screen">
        <p className="text-gray-500">Checking authenticationâ€¦</p>
      </div>
    );
  }

  // If user is authenticated, render children
  return <>{children}</>;
}



===== components/VideoCard.tsx =====
"use client";

import { useState } from "react";
import Link from "next/link";
import { updateVideo, moveToTrash, restoreVideo } from "@/lib/api";

interface Props {
  video: any;
  onUpdated: () => void;
}

export default function VideoCard({ video, onUpdated }: Props) {
  const [editing, setEditing] = useState(false);
  const [title, setTitle] = useState(video.title || "");
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleSave = async () => {
    setLoading(true);
    setError(null);
    try {
      await updateVideo(video.id, { title });
      setEditing(false);
      onUpdated();
    } catch (e: any) {
      setError(e.message);
    } finally {
      setLoading(false);
    }
  };

  const handleTrash = async () => {
    if (!confirm("Move this video to trash?")) return;
    setLoading(true);
    try {
      await moveToTrash(video.id); // PATCH { action: "trash" }
      onUpdated();
    } finally {
      setLoading(false);
    }
  };

  const handleRestore = async () => {
    if (!confirm("Restore this video?")) return;
    setLoading(true);
    try {
      await restoreVideo(video.id); // PATCH { action: "restore" }
      onUpdated();
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="relative border rounded-lg p-4 shadow bg-white">
      {loading && (
        <div className="absolute inset-0 bg-white/70 flex items-center justify-center z-10 rounded-lg">
          <div className="w-6 h-6 border-4 border-blue-500 border-t-transparent rounded-full animate-spin" />
        </div>
      )}

      <div className="flex items-center gap-2">
        {editing ? (
          <>
            <input
              value={title}
              onChange={(e) => setTitle(e.target.value)}
              className="border px-2 py-1 rounded flex-1"
            />
            <button onClick={handleSave} className="px-3 py-1 bg-blue-600 text-white rounded">
              Save
            </button>
            <button onClick={() => setEditing(false)} className="px-3 py-1 border rounded">
              Cancel
            </button>
          </>
        ) : (
          <>
            <h3 className="font-semibold flex-1">
              <Link href={`/videos/${video.id}`} className="hover:underline">
                {video.title || "Untitled"}
              </Link>
            </h3>
            <button onClick={() => setEditing(true)} className="px-3 py-1 border rounded">
              Edit
            </button>
          </>
        )}
      </div>

      {video.signed_url ? (
        <video controls src={video.signed_url} className="w-full h-48 object-cover mt-2 rounded" />
      ) : (
        <p className="text-sm text-gray-500 mt-2">No video file</p>
      )}

      <div className="flex gap-2 mt-3">
        {!video.is_deleted ? (
          <button onClick={handleTrash} className="px-3 py-1 bg-red-600 text-white rounded">
            Move to Trash
          </button>
        ) : (
          <button onClick={handleRestore} className="px-3 py-1 bg-green-600 text-white rounded">
            Restore
          </button>
        )}
      </div>

      {error && <p className="text-red-600 mt-2">{error}</p>}
    </div>
  );
}



===== tests/day12.spec.ts =====
import { test, expect } from "@playwright/test";

const BASE_URL = "http://localhost:3000"; // adjust if needed

test.describe("Day 12 Verification", () => {
  test("Feed page loads videos or empty state", async ({ page }) => {
    await page.goto(`${BASE_URL}/feed`);
    await expect(
      page.locator("text=Loading videosâ€¦").or(
        page.locator("text=No videos uploaded yet").or(page.locator("video"))
      )
    ).toBeVisible();
  });

  test("Profile redirects to login when logged out", async ({ page }) => {
    await page.goto(`${BASE_URL}/profile`);
    await expect(page).toHaveURL(/.*login/);
  });

  test("Navbar links exist", async ({ page }) => {
    await page.goto(BASE_URL);
    await expect(page.locator("a:has-text('Feed')")).toBeVisible();
    await expect(page.locator("a:has-text('Profile')")).toBeVisible();
    await expect(page.locator("a:has-text('Upload')")).toBeVisible();
  });

  // Optional: requires a test Firebase user
  test("Profile shows only current user's videos after login", async ({ page }) => {
    await page.goto(`${BASE_URL}/login`);
    await page.fill('input[type="email"]', "testuser@example.com");
    await page.fill('input[type="password"]', "password123");
    await page.click('button:has-text("Login")');

    await page.goto(`${BASE_URL}/profile`);
    const cards = await page.locator("video").count();
    expect(cards).toBeGreaterThanOrEqual(0); // adjust with stricter checks if needed
  });
});



===== tests/day13.spec.ts =====
import { test, expect } from "@playwright/test";

const BASE_URL = "http://localhost:3000";

test.describe("Day 13 â€” Edit & Delete Video", () => {
  test("Logged-in user can edit and delete their own video", async ({ page }) => {
    // Step 1: Login as actual video owner
    await page.goto(`${BASE_URL}/login`);
    await page.fill('input[type="email"]', "priyashish10dec@gmail.com");
    await page.fill('input[type="password"]', "your_password_here");
    await page.click("button:has-text('Login')");

    // Step 2: Go to profile
    await page.goto(`${BASE_URL}/profile`);

    // Step 3: Check if any videos exist
    const editButton = page.locator("button", { hasText: "Edit" }).first();
    if (await editButton.count() === 0) {
      console.log("No videos found for editing â€” skipping test.");
      return;
    }

    // Step 4: Edit title
    await editButton.click();
    const input = page.locator("input").first();
    await input.fill("Updated Title");
    await page.click("button", { hasText: "Save" });
    await expect(page.locator("text=Updated Title")).toBeVisible();

    // Step 5: Delete video
    const deleteButton = page.locator("button", { hasText: "Delete" }).first();
    page.once("dialog", (dialog) => dialog.accept());
    const videoCountBefore = await page.locator("video").count();
    await deleteButton.click();
    await expect(async () => {
      const videoCountAfter = await page.locator("video").count();
      expect(videoCountAfter).toBeLessThan(videoCountBefore);
    }).toPass();
  });
});



===== tests/day14.spec.ts =====
import { test, expect } from "@playwright/test";

const BASE_URL = process.env.BASE_URL || "http://localhost:3000";

let seededVideoId: string;

async function ensureUser(request) {
  await request.post(`${BASE_URL}/api/test-ensure-user`, {
    data: {
      email: process.env.TEST_USER_EMAIL!,
      password: process.env.TEST_USER_PASSWORD!,
    },
  });
}

async function login(page) {
  await page.goto(`${BASE_URL}/login`, { waitUntil: "domcontentloaded" });
  await page.getByPlaceholder("Email").fill(process.env.TEST_USER_EMAIL!);
  await page.getByPlaceholder("Password").fill(process.env.TEST_USER_PASSWORD!);
  await page.getByRole("button", { name: "Login" }).click();
  await page.waitForURL("**/profile", { timeout: 30000 });
  await expect(page.locator("text=My Videos")).toBeVisible({ timeout: 30000 });
}

test.describe("Day 14 â€” Watch, Soft Delete, Restore", () => {
  test.beforeEach(async ({ request, page }) => {
    await ensureUser(request);

    const response = await request.post(`${BASE_URL}/api/seed-video`);
    const data = await response.json();
    seededVideoId = data.videoId;
    // allow storage/db to settle
    await new Promise((res) => setTimeout(res, 1500));

    await login(page);
  });

  test.afterEach(async ({ request }) => {
    await request.delete(`${BASE_URL}/api/cleanup-video?id=${seededVideoId}`);
  });

  test("Watch page loads signed URL", async ({ page }) => {
    const videoLink = page.locator(`a[href="/watch/${seededVideoId}"]`);
    await expect(videoLink).toBeVisible({ timeout: 15000 });
    await videoLink.click();
    await expect(page.locator("video")).toBeVisible({ timeout: 15000 });
  });

  test("Soft delete moves video to Trash", async ({ page }) => {
    await expect(page.locator("text=Seeded Test Video")).toBeVisible({ timeout: 15000 });
    await page.locator('button:has-text("Delete")').first().click();
    await expect(page.locator("text=Trash")).toBeVisible({ timeout: 15000 });
    await expect(page.locator("text=Seeded Test Video")).toBeVisible({ timeout: 15000 });
  });

  test("Restore moves video back", async ({ page }) => {
    await page.locator('button:has-text("Delete")').first().click();
    await expect(page.locator("text=Trash")).toBeVisible({ timeout: 15000 });
    await expect(page.locator("text=Seeded Test Video")).toBeVisible({ timeout: 15000 });

    await page.locator('button:has-text("Restore")').first().click();
    await expect(page.locator("text=My Videos")).toBeVisible({ timeout: 15000 });
    await expect(page.locator("text=Seeded Test Video")).toBeVisible({ timeout: 15000 });
  });
});



===== tests/day15.spec.ts =====
import { test, expect, request } from "@playwright/test";

const BASE = process.env.BASE_URL || "http://localhost:3000";
const TEST_EMAIL = process.env.TEST_USER_EMAIL || "test-user+1@example.com";
const TEST_PASSWORD = process.env.TEST_USER_PASSWORD || "TestPassword123!";

test.describe("Day 15 - Test Automation Foundation", () => {
  let seededVideo: { videoId: string | number; filePath: string };
  let testUid: string;

  test.beforeEach(async ({ page }) => {
    // 1) ensure test user exists via API
    const apiContext = await request.newContext();
    const ensureResp = await apiContext.post(`${BASE}/api/test-ensure-user`, {
      data: { email: TEST_EMAIL, password: TEST_PASSWORD },
    });
    expect(ensureResp.ok()).toBeTruthy();
    const ensureJson = await ensureResp.json();
    // ensure API returns uid on success
    testUid = ensureJson.uid || process.env.TEST_USER_UID || "dev-seed-user";

    // 2) seed video for this user by calling seed API with override header (DEV only)
    const seedResp = await apiContext.post(`${BASE}/api/seed-video`, {
      headers: {
        "x-test-uid": testUid,
      },
    });
    expect(seedResp.ok()).toBeTruthy();
    seededVideo = await seedResp.json();
    expect(seededVideo.videoId).toBeTruthy();
  });

  test("upload â†’ watch â†’ delete â†’ restore (UI flow)", async ({ page }) => {
    // 1) login via UI
    await page.goto(`${BASE}/login`);
    // The login page selectors may vary â€” adjust if your project uses different ids.
    await page.fill('input[name="email"]', TEST_EMAIL);
    await page.fill('input[name="password"]', TEST_PASSWORD);
    await page.click('button[type="submit"]');
    // wait for redirect to profile or homepage
    await page.waitForURL(`${BASE}/profile`, { timeout: 10000 });

    // 2) Verify seeded video appears in profile
    await page.goto(`${BASE}/profile`);
    // look for card with title "Seeded Test Video"
    const videoCard = page.locator('text=Seeded Test Video').first();
    await expect(videoCard).toBeVisible({ timeout: 10000 });

    // 3) Click to watch
    await videoCard.click();
    // expect URL to be /watch/:id
    await expect(page).toHaveURL(new RegExp(`/watch/${seededVideo.videoId}`), { timeout: 10000 });

    // 4) Check playback element exists (video tag or player)
    const videoEl = page.locator('video').first();
    await expect(videoEl).toBeVisible();

    // 5) Click Delete (UI must have a Delete button on watch or profile)
    // Try buttons in order: [aria-label=Delete], text "Delete", button.delete
    const deleteBtn = page.locator('button:has-text("Delete")').first();
    await expect(deleteBtn).toBeVisible({ timeout: 5000 });
    await deleteBtn.click();

    // After delete, the UI should move video to Trash â€” go to profile and check Trash
    await page.goto(`${BASE}/profile`);
    await page.click('text=Trash', { timeout: 5000 }).catch(() => {});
    // Expect not in My Videos list
    const notInMyVideos = page.locator('text=Seeded Test Video');
    await expect(notInMyVideos).toBeHidden();

    // 6) Restore via UI: find Restore button in Trash
    const restoreBtn = page.locator('button:has-text("Restore")').first();
    await expect(restoreBtn).toBeVisible({ timeout: 5000 });
    await restoreBtn.click();

    // After restore, check it reappeared in My Videos
    await page.goto(`${BASE}/profile`);
    const backInMyVideos = page.locator('text=Seeded Test Video').first();
    await expect(backInMyVideos).toBeVisible({ timeout: 10000 });
  });

  test.afterEach(async () => {
    // cleanup the seeded video using the cleanup API
    const apiContext = await request.newContext();
    await apiContext.post(`${BASE}/api/cleanup-video`, {
      data: { id: seededVideo.videoId, remove_file: true },
      headers: { "x-test-uid": testUid },
    });
  });
});



===== tests/seo-check.js =====
// seo-check.js
// Run with: node seo-check.js http://localhost:3000/videos/<id>

import { chromium } from "playwright";

async function checkSEO(url) {
  const browser = await chromium.launch();
  const page = await browser.newPage();
  await page.goto(url, { waitUntil: "domcontentloaded" });

  const results = {};

  // Grab all meta/link/script tags
  const title = await page.title();
  results.title = title || "âŒ Missing";

  const description = await page.$eval(
    'meta[name="description"]',
    el => el.content,
  ).catch(() => null);
  results.description = description || "âŒ Missing";

  const ogTitle = await page.$eval(
    'meta[property="og:title"]',
    el => el.content,
  ).catch(() => null);
  results.ogTitle = ogTitle || "âŒ Missing";

  const ogDesc = await page.$eval(
    'meta[property="og:description"]',
    el => el.content,
  ).catch(() => null);
  results.ogDescription = ogDesc || "âŒ Missing";

  const ogType = await page.$eval(
    'meta[property="og:type"]',
    el => el.content,
  ).catch(() => null);
  results.ogType = ogType || "âŒ Missing";

  const ogImage = await page.$eval(
    'meta[property="og:image"]',
    el => el.content,
  ).catch(() => null);
  results.ogImage = ogImage || "âŒ Missing";

  const twCard = await page.$eval(
    'meta[name="twitter:card"]',
    el => el.content,
  ).catch(() => null);
  results.twitterCard = twCard || "âŒ Missing";

  const twTitle = await page.$eval(
    'meta[name="twitter:title"]',
    el => el.content,
  ).catch(() => null);
  results.twitterTitle = twTitle || "âŒ Missing";

  const twDesc = await page.$eval(
    'meta[name="twitter:description"]',
    el => el.content,
  ).catch(() => null);
  results.twitterDescription = twDesc || "âŒ Missing";

  const twImage = await page.$eval(
    'meta[name="twitter:image"]',
    el => el.content,
  ).catch(() => null);
  results.twitterImage = twImage || "âŒ Missing";

  const canonical = await page.$eval(
    'link[rel="canonical"]',
    el => el.href,
  ).catch(() => null);
  results.canonical = canonical || "âŒ Missing";

  // JSON-LD VideoObject
  const jsonLd = await page.$$eval(
    'script[type="application/ld+json"]',
    els => els.map(el => el.innerText),
  );
  results.jsonLdVideoObject = jsonLd.find(j => j.includes('"VideoObject"'))
    ? "âœ… Present"
    : "âŒ Missing";

  console.log(`\nğŸ” SEO Report for ${url}`);
  console.table(results);

  await browser.close();
}

// Run with CLI arg
const url = process.argv[2];
if (!url) {
  console.error("Usage: node seo-check.js <url>");
  process.exit(1);
}
checkSEO(url);



===== tests/setup/auth.setup.ts =====
import { test as setup, expect } from "@playwright/test";
import { createUser, deleteUser } from "../utils/test-user";

const authFile = "playwright/.auth/user.json";

setup("authenticate", async ({ page }) => {
  const email = process.env.TEST_USER_EMAIL!;
  const password = process.env.TEST_USER_PASSWORD!;
  
  // Create test user if it doesn't exist
  await createUser(email, password);
  
  // Perform authentication
  await page.goto("/login");
  await page.fill('input[type="email"]', email);
  await page.fill('input[type="password"]', password);
  await page.click('button[type="submit"]');
  
  // Wait for redirect to profile page
  await page.waitForURL("/profile");
  
  // Save authentication state
  await page.context().storageState({ path: authFile });
  
  // Verify authentication worked
  await expect(page.locator("h1")).toHaveText("My Videos");
});

// Cleanup after all tests
setup.afterAll(async () => {
  if (process.env.CLEANUP_TEST_USER !== "false") {
    await deleteUser(process.env.TEST_USER_EMAIL!);
  }
});



===== SELECTED TOP-LEVEL FILES =====
===== IdTokenProvider.tsx =====
"use client";

import { useEffect } from "react";
import { getAuth, onAuthStateChanged } from "firebase/auth";

export default function IdTokenProvider() {
  useEffect(() => {
    const auth = getAuth();
    onAuthStateChanged(auth, async (user) => {
      if (user) {
        const token = await user.getIdToken();
        (window as any).__ID_TOKEN__ = token;
      } else {
        (window as any).__ID_TOKEN__ = null;
      }
    });
  }, []);

  return null; // nothing to render
}



===== next.config.ts =====
const path = require("path");

/** @type {import('next').NextConfig} */
module.exports = {
  reactStrictMode: true,
  webpack(config) {
    config.resolve.alias["@"] = path.resolve(__dirname, "src");
    return config;
  },
};



===== playwright.config.ts =====
import { defineConfig, devices } from "@playwright/test";
import * as dotenv from "dotenv";

dotenv.config({ path: ".env.local" });

export default defineConfig({
  testDir: "./tests",
  timeout: 60_000,
  expect: { timeout: 10_000 },
  use: {
    baseURL: process.env.BASE_URL || "http://localhost:3000",
    trace: "on-first-retry",
    video: "retain-on-failure",
  },
  projects: [
    {
      name: "chromium",
      use: { ...devices["Desktop Chrome"] },
    },
  ],
});



===== tsconfig.json =====
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,

    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"],
      "@/components/*": ["components/*"],
      "@/hooks/*": ["src/hooks/*"]
    },

    "plugins": [
      { "name": "next" }
    ]
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}



===== firebaseConfig.js =====
import { initializeApp } from "firebase/app";
import { getAuth } from "firebase/auth";
import { getStorage } from "firebase/storage";

const firebaseConfig = {
  apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,
  authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,
  projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,
  storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,
  appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID,
};

const app = initializeApp(firebaseConfig);

export const auth = getAuth(app);
export const storage = getStorage(app);



===== package.json =====
{
  "name": "web",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "test:e2e": "playwright test"
  },
  "dependencies": {
    "@supabase/supabase-js": "^2.56.1",
    "firebase": "^12.2.1",
    "firebase-admin": "^13.5.0",
    "framer-motion": "^12.23.12",
    "next": "15.5.0",
    "next-auth": "^4.24.11",
    "react": "19.1.0",
    "react-dom": "19.1.0",
    "react-firebase-hooks": "^5.1.1",
    "react-hot-toast": "^2.6.0",
    "sonner": "^2.0.7"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@playwright/test": "^1.55.0",
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "dotenv": "^17.2.2",
    "eslint": "^9",
    "eslint-config-next": "15.5.0",
    "tailwindcss": "^4",
    "typescript": "^5"
  }
}


